<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fast Video Audio Extractor</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            line-height: 1.8;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #progressBar {
            width: 100%;
            background-color: #f0f0f0;
            padding: 3px;
            border-radius: 3px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, .2);
        }
        #progressBar div {
            width: 0;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 3px;
            transition: width 0.5s ease-in-out;
        }
    </style>
</head>
<body>
    <h1>Fast Video Audio Extractor</h1>
    <input type="file" accept="video/*" id="videoInput">
    <div id="processingMessage" style="display: none;">
        <p>Extracting audio... Please wait.</p>
        <div id="progressBar"><div></div></div>
        <p id="percentageText">0%</p>
    </div>
    <div id="audioOutput" style="display: none;">
        <h2>Extracted Audio</h2>
        <audio controls id="audioPlayer"></audio>
        <br>
        <a id="downloadLink" download="extracted_audio.wav">Download Audio</a>
    </div>

    <script>
        const videoInput = document.getElementById('videoInput');
        const processingMessage = document.getElementById('processingMessage');
        const audioOutput = document.getElementById('audioOutput');
        const audioPlayer = document.getElementById('audioPlayer');
        const downloadLink = document.getElementById('downloadLink');
        const progressBar = document.querySelector('#progressBar div');
        const percentageText = document.getElementById('percentageText');

        videoInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            console.log('File selected:', file.name);
            processingMessage.style.display = 'block';
            audioOutput.style.display = 'none';
            progressBar.style.width = '0%';
            percentageText.textContent = '0%';

            const audioContext = new AudioContext();
            const fileReader = new FileReader();

            fileReader.onload = async function(e) {
                const arrayBuffer = e.target.result;
                try {
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const offlineContext = new OfflineAudioContext(
                        audioBuffer.numberOfChannels,
                        audioBuffer.length,
                        audioBuffer.sampleRate
                    );

                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start();

                    offlineContext.startRendering().then(renderedBuffer => {
                        const wav = audioBufferToWav(renderedBuffer);
                        const blob = new Blob([wav], { type: 'audio/wav' });
                        const url = URL.createObjectURL(blob);
                        audioPlayer.src = url;
                        downloadLink.href = url;
                        processingMessage.style.display = 'none';
                        audioOutput.style.display = 'block';
                        console.log('Processing complete');
                    }).catch(err => {
                        console.error('Rendering failed:', err);
                    });

                    offlineContext.oncomplete = function(e) {
                        console.log('Rendering completed successfully');
                    };

                    let lastUpdateTime = Date.now();
                    offlineContext.suspend(0).then(function renderInChunks() {
                        const currentTime = Date.now();
                        if (currentTime - lastUpdateTime > 100) {
                            const progress = (offlineContext.currentTime / audioBuffer.duration) * 100;
                            progressBar.style.width = `${progress}%`;
                            percentageText.textContent = `${Math.round(progress)}%`;
                            lastUpdateTime = currentTime;
                        }
                        offlineContext.resume();
                        if (offlineContext.state !== "closed") {
                            offlineContext.suspend(offlineContext.currentTime + 1).then(renderInChunks);
                        }
                    });
                } catch (e) {
                    console.error('Error decoding audio data:', e);
                }
            };

            fileReader.readAsArrayBuffer(file);
        });

        // Function to convert AudioBuffer to WAV format
        function audioBufferToWav(buffer, opt) {
            opt = opt || {};
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = opt.float32 ? 3 : 1;
            const bitDepth = format === 3 ? 32 : 16;

            let result;
            if (numChannels === 2) {
                result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
            } else {
                result = buffer.getChannelData(0);
            }

            return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
        }

        function interleave(inputL, inputR) {
            const length = inputL.length + inputR.length;
            const result = new Float32Array(length);

            let index = 0;
            let inputIndex = 0;

            while (index < length) {
                result[index++] = inputL[inputIndex];
                result[index++] = inputR[inputIndex];
                inputIndex++;
            }
            return result;
        }

        function encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
            const view = new DataView(buffer);

            /* RIFF identifier */
            writeString(view, 0, 'RIFF');
            /* RIFF chunk length */
            view.setUint32(4, 36 + samples.length * bytesPerSample, true);
            /* RIFF type */
            writeString(view, 8, 'WAVE');
            /* format chunk identifier */
            writeString(view, 12, 'fmt ');
            /* format chunk length */
            view.setUint32(16, 16, true);
            /* sample format (raw) */
            view.setUint16(20, format, true);
            /* channel count */
            view.setUint16(22, numChannels, true);
            /* sample rate */
            view.setUint32(24, sampleRate, true);
            /* byte rate (sample rate * block align) */
            view.setUint32(28, sampleRate * blockAlign, true);
            /* block align (channel count * bytes per sample) */
            view.setUint16(32, blockAlign, true);
            /* bits per sample */
            view.setUint16(34, bitDepth, true);
            /* data chunk identifier */
            writeString(view, 36, 'data');
            /* data chunk length */
            view.setUint32(40, samples.length * bytesPerSample, true);
            if (format === 1) { // Raw PCM
                floatTo16BitPCM(view, 44, samples);
            } else {
                writeFloat32(view, 44, samples);
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }

        function writeFloat32(output, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 4) {
                output.setFloat32(offset, input[i], true);
            }
        }
    </script>
</body>
</html>
